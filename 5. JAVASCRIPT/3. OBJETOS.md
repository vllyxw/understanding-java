<h2>OBJETOS</h2>

Objetos é sempre composto de conjuntos de chave e valor

Exemplo:

~~~
const objPessoa = {
	nome: 'José Silva',
	idade: 32,
	cpf: '123456232221',
	turma: 'JavaScript'
}
~~~

<b>Acessando objetos</b>

Exemplo:

~~~
const estudante = {
	nome: 'José Silva',
	idade: 32,
	cpf: '123456232221',
	turma: 'JavaScript'
}

console.log(estudante.nome); // retornar nome conforme referenciado dentro do objeto

console.log('o nome de estudante é ${estudante.nome}');

console.log('os três primeiros números do CPF são ${estudante.cpf.substring(0, 3)}'); //método substring passa índice de inicio e um indicio de final e pegar uma parte do string
~~~

<b>Adicionando e alterando objetos</b>

Exemplo 1 - Adicionar objeto:

~~~
const estudante = {
	nome: 'José Silva',
	idade: 32,
	cpf: '123456232221',
	turma: 'JavaScript'
}

estudante.telefone = '2584598455'; // adicionando objeto aqui
console.log(estudante);
~~~

Exemplo 2 - Alterando objeto:

~~~
const estudante = {
	nome: 'José Silva',
	idade: 32,
	cpf: '123456232221',
	turma: 'JavaScript'
}

estudante.nome = 'José Souza'; //alterando um objeto já existente aqui
console.log(estudante);
~~~


<b>Tipo de dados e valores com objetos</b>

Exemplo:

~~~
const estudante = {
	nome: 'José Silva',
	idade: 32,
	cpf: '123456232221',
	turma: 'JavaScript'
	bolsista: true,
	telefones: ['5547988558825', '55479999854765'] //deixa de ser uma propriedade string e passar ser um array
}

console.log(estudante.telefones[0]); //trazendo o primeiro telefone na primeira posição
~~~

<b>Objetos em objetos</b>

Exemplo:

~~~
const estudante = {
	nome: 'José Silva',
	idade: 32,
	cpf: '123456232221',
	turma: 'JavaScript'
	bolsista: true,
	telefones: ['5547988558825', '55479999854765'] 
}

estudante.endereco = {
	rua: 'Rua Joseph Climber',
	numero: '45',
	complemento: 'apto 43'
} //adição de um objeto dentro de outro objeto

console.log(estudante)

console.log(estudante.endereco.rua); //acessar somente a propriedade rua
~~~

<b>Lista de objetos</b>

Exemplo:

~~~
const estudante = {
	nome: 'José Silva',
	idade: 32,
	cpf: '123456232221',
	turma: 'JavaScript'
	bolsista: true,
	telefones: ['5547988558825', '55479999854765'] 
	endereços: [{ // [] formou-se as propriedades desse objeto em arrays
		rua: 'Rua Joseph Climber',
		numero: '45',
		complemento: 'apto 43'
	}]

}


estudante.enderecos.push({ // adicionando mais um objeto dentro da array do objeto enderecos
	rua: 'Rua Dona Clotilde',
	numero: '71',
	complemento: null
})

const listaEnderecosComComplemento = estudante.enderecos.filter((endereço) => endereço.complemento)

console.log(listaEnderecosComComplemento);
~~~

<b>Funções - Atribuição de comportamentos</b>

Exemplo 1:

~~~
const estudante = {
	nome: 'José Silva',
	idade: 32,
	cpf: '123456232221',
	turma: 'JavaScript'
	bolsista: true,
	telefones: ['5547988558825', '55479999854765'] 
	media: 7.5,
	estaAprovado: function(mediaBase) {
		return this.media >= mediaBase ? true : false;
	}

}

console.log(estudante.estaAprovado);
~~~

<b>Arrow functions e o this</b>

As arrow functions não possuem um this próprio. Em vez disso, elas herdam o valor de this do contexto em que foram definidas. Isso pode causar problemas em métodos de objetos, pois this pode não se referir ao objeto esperado

Exemplo 2:

~~~
const pessoa = {
	nome: "João",
	idade: 25,
	apresentar: () => {
	console.log(`Olá, meu nome é ${this.nome} e eu tenho ${this.idade} anos.`);
	}
};

pessoa.apresentar(); // Saída: Olá, meu nome é undefined e eu tenho undefined anos.
~~~

